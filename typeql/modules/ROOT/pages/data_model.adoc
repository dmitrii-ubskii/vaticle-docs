= Data and query model

This page gives a brief overview of TypeDB's data and query model.

== Type system

TypeDB's type system distinguishes types as follows.

* *User-defined types*. Types defined in the schema of the database.
11. *Entity types*, specified using the keyword `entity`.
+
--
Instances of entity types, simply called entities, can be created _indepdently_, i.e., without reference to other data instance.

Entity types can have capabilities, i.e. play roles or own attribute types. This allows us to create connections between
--
11. *Relation types*, specified using the keyword `relation`, and require to have at least one *associated role type* specified with the keyword `relates`.
+
--
Instances of relation types reference (or "link") other data instances, called their *role players*. For example, a friendship relations may link two friends (implemented by, say, two user entities). Relations without role players will be removed (no "`dangling relations`").

Relation types can have capabilities, i.e. play roles or own attribute types.
--
11. *Attribute types*, specified using the keyword `attribute`, and required to have an *associated value type* (either structured or primitive) specified with the keyword `value`.
+
--
Instances of attribute types carry an associated value of the associated type. They also come with references to their *owners*. Attributes without owners will be removed (no "`dangling attributes`", unless the attribute type is marked as independent.)

Two attributes are considered equal if they have the same associate value and have the same (origin) type.
--
11. *Structured value types*, specified using the keyword `struct` and used in the context of defining attribute types via the keyword `value`.
+
[NOTE]
====
Coming soon.
====

* *Built-in types* (and type operators).
11. *Primitive value types*, used in the context of defining attribute types via the keyword `value`.
+
--
Two instances of a value type are equal exactly when their literal values are equal (as checked with equality comparison `==`).
--
11. *List types*, used by the syntax `[<T>]` for a non-list type `<T>` (which can be either built-in or user-defined).
+
[NOTE]
====
Coming soon.
====

== User definitions

User-defined types are created and modified through xref:{page-version}@typeql::introduction.adoc#statements[definition statements] in xref:{page-version}@typeql::introduction.adoc#queries[schema queries].

== Variables in patterns

In any valid TypeQL xref:{page-version}@typeql::introduction.adoc#queries[data pipeline], there are four categories of variables appearing in xref:{page-version}@typeql::introduction.adoc#statements[statements]. Any variable (unambiguously) belongs to exactly one of those four categories.

1. *Instance variables*, represent data instances from your database. Instance variables are identified by their usage in statements. For example:
+
--
[,typeql]
----
match $someone isa $user;
----
implies that `$someone` isa an instance variable.
--
1. *Value variables*, represent values that are computed as part of your query. Value variables are identified by their usage in statements. For example:
+
--
[,typeql]
----
match let $computed_val = $other_val + 1;
----
implies that `$computed_val` is a value variable.
--
1. *Type variables*, represent type labels. As before, they are identified by their usage in statements. For example:
+
--
[,typeql]
----
match $something isa $type;
----
implies that `$type` is a type variable.
--
1. *List variables*.
+
[NOTE]
====
Coming soon.
====

== Variable modes in matches

Given a `match` stage in a data pipeline, each variable in that stage can appear in one of the following three modes.

* *Input* (or "`bound`") variables are variables that are bound in a preceding stage. For example,
+
--
[,typeql]
----
match $x isa user, has age 33;
limit 1;
match friendship ($y, $x);  # $x is an input at this stage
----
--
* *Output* variables are unbound variables that are part of the present stage's output (at least in one `or`-branch of the query). For example, in the query
+
--
[,typeql]
----
match
 $x isa user;
 { $x isa VIP; }
 or { $x isa admin, has access-level $lvl; $lvl > 9000; };
----
both `$u` and `$lvl` are returnable variables.

*Optional* variables are a subclass of returnable variables: these or variables that may be left empty in the stages output (you may think of this as assigning them to the unit `()` of the unit type, which is implicit in our type system).
[NOTE]
====
Further optionality features coming soon!
====
--
* *Internal* variables are variables that are not returned by the stage. The prototypical example is a `not` query, like
+
--
[,typeql]
----
match
  $x isa user;
  not { friendship ($x, $y); }
----
where the variable `$y` is internal. The class of internal variable also includes *anonymous* variables (indicated by `$_`).

An important aspect of internal variables is they do not lead to result duplication. For example,
[,typeql]
----
match
  $x isa user;
  friendship ($x, $_);
----
will return exactly the set of users (instead of a copy of the same user for each of their friends).
--


== Query evaluation

Queries are evaluated in two stages:

1. *Type inference*. TypeDB will double-check which combinations of types are valid given the constraints in your query. If a non-type variable cannot be assigned a type, the query will fail at this stage with a type inference error.
1. *Stage-by-stage evaluation*. Stage in the data pipeline are evaluated one after the other. In each case, for each output row from the previous stage the present stage, will produce n output rows (n may be zero), and pass each such row, after augmenting it with its own input, as an input row to the next stage.

=== Recursive queries

Recursive queries are evaluated in accordance with the principles of stratified negation.