= `@abstract` annotation
:page-aliases: {page-version}@typeql::statements/abstract.adoc

`@abstract` annotation is used
// tag::overview[]
to specify that a type is abstract.
// end::overview[]

== Syntax

.Syntax
[,typeql]
----
<type label> @abstract;
----

The `@abstract` annotation doesn't accept any arguments, so after the `abstract` keyword always follows either a comma or a semicolon.

== Usage
TypeQL statements with the `@abstract` annotation are used to define an `abstract` constraint for a type (i.e., to declare that a type is abstract).

An abstract type cannot be used to insert a data instance but can be used to create a subtype or to query (for its subtypes).

[,typeql]
----
include::{page-version}@typeql::example$tql/schema_annotations.tql[tags=define-keyword;abstract-entity;]
----

=== Subtyping

`abstract` constraint is not inheritable. It makes all the subtypes of an abstract type concrete, which allows the creation of their instances.

It is possible to define an abstract subtype of an abstract type.

[,typeql]
----
include::{page-version}@typeql::example$tql/schema_annotations.tql[tags=define-keyword;abstract-attribute]
----

However, it is impossible to define an abstract subtype of a concrete type.

.A wrong definition!
[,typeql]
----
define
  attribute categorized-username @abstract, sub username;
----

=== Role types specialization

// TODO: Add a hyperlink to "relates as"
Similarly, abstract role types cannot be instantiated, and a concrete sub role type can be defined using **specialization** (keyword `as`).

[,typeql]
----
include::{page-version}@typeql::example$tql/schema_annotations.tql[tags=define-keyword;abstract-relation]
----
