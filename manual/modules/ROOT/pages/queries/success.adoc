= Query answers
:page-aliases: {page-version}@manual::objects/data.adoc, {page-version}@manual::objects/explanation.adoc, {page-version}@manual::objects/overview.adoc, {page-version}@manual::objects/schema.adoc

This page gives a brief overview of answer types returned by the server when running queries.

== Query types

xref:{page-version}@typeql::index.adoc#queries[Data pipelines] produce query answers. Currently TypeDB supports two answers formats: concept
rows (the native TypeDB format) and JSON.

In contrast, xref:{page-version}@typeql::index.adoc#queries[schema queries] do not produce answers, but only return success/failures
notifications.

== Concept rows

Any valid data pipeline not ending with a `fetch` stage will produce answers in xref:{page-version}@manual::CRUD/outputs.adoc#crows[concept row
format].

[tabs]
====
Studio::
+
--
Follow the xref:{page-version}@manual::studio.adoc#_connect_to_typedb[Studio manual]
to connect to TypeDB and select a project folder.
Then use the steps below:

. Use a drop-down list in the top toolbar to select a database.
. Select the desired transaction type.
. Open a new tab and insert or type in an insert stage, for example:
+
. Run the query by clicking the image:{page-version}@home::studio-icons/svg/studio_run.svg[width=24] btn:[Run Query] button.
. Commit the changes by clicking the image:{page-version}@home::studio-icons/svg/studio_check.svg[width=24] btn:[Commit query] button.

.Sample query
[,typeql]
----
match
  $user1 has username $name1;
  $user2 has username $name2;
  friendship($user1, $user2);
  $name1 < $name2;
----

Each concept row is printed as a table where the left column is the variable name, and the right is the variable's value in the row.

.Sample output
[,typeql]
----
## Running>
match
  $user1 has username $name1;
  $user2 has username $name2;
  friendship($user1, $user2);
  $name1 < $name2;

## Result> Success.
    $name1 | user1 isa username
    $name2 | user2 isa username
    $user1 | iid 0x1e00000000000000000011 isa user
    $user2 | iid 0x1e00000000000000000012 isa user
   ------------
    $name1 | user1 isa username
    $name2 | user3 isa username
    $user1 | iid 0x1e00000000000000000011 isa user
    $user2 | iid 0x1e00000000000000000013 isa user
   ------------
## Completed
----

--

Console::
+
--
Start a transaction of the desired type (`read`, `write`, or `schema`):

[,bash]
----
> transaction sample_db read
sample_db::read>
----

Each concept row is printed as a table where the left column is the variable name, and the right is the variable's value in the row.

[,bash]
----
sample_db::read> match
                   $user1 has username $name1;
                   $user2 has username $name2;
                   friendship ($user1, $user2);
                   $name1 < $name2;

Finished validation and compilation...
Streaming answers...

   ------------
    $name1 | user1 isa username
    $name2 | user2 isa username
    $user1 | iid 0x1e00000000000000000014 isa user
    $user2 | iid 0x1e00000000000000000015 isa user
   ------------
    $name1 | user1 isa username
    $name2 | user3 isa username
    $user1 | iid 0x1e00000000000000000014 isa user
    $user2 | iid 0x1e00000000000000000016 isa user
   ------------

Finished. Total answers: 2
----

If you made any changes and are ready to commit, simply type `commit`:

[,bash]
----
sample_db::write> commit
Transaction changes committed
----

If you wish to close the transaction without committing instead, you can press kbd:[Ctrl+C] (interrupt) or kbd:[Ctrl+D] (end of input).
--
====

[tabs]
====
Rust::
+
--
Follow the xref:{page-version}@manual::connecting/connection.adoc[connection guide]
to connect the `driver` to a TypeDB server.

[subs="macros, post_replacements, replacements"]
++++
Open a transaction to the selected database and use the
xref:{page-version}@drivers::rust/api-reference.adoc#_struct_Transaction_query__[transaction.query()]
method to send the query:
++++

[,rust,indent=0]
----
let transaction = driver.transaction(DB_NAME, TransactionType::Read).await.unwrap()?;
let query = "
  match
    $user1 has username $name1;
    $user2 has username $name2;
    friendship($user1, $user2);
    $name1 < $name2;
";
let answers = transaction.query(query).await?;
----

Where `answers` is a `QueryAnswer` holding the `ConceptRowHeader` with the output variable names for reference, as well as a stream of
``ConceptRow``s. Each `ConceptRow` is a mapping from variable names (not including the `$` sigil) to their values in the row.
--

Python::
+
--
Follow the xref:{page-version}@manual::connecting/connection.adoc[connection guide]
to connect the `driver` to a TypeDB server.

[subs="macros, post_replacements, replacements"]
++++
Open a transaction to the selected database and use the
xref:{page-version}@drivers::python/api-reference.adoc#_Transaction_query[transaction.query()]
method to send the query:
++++

[,python,indent=0]
----
with driver.transaction(DB_NAME, TransactionType.READ) as tx:
    query = """
      match
        $user1 has username $name1;
        $user2 has username $name2;
        friendship($user1, $user2);
        $name1 < $name2;
    """
    answers = tx.query(insert_query).resolve()
----

Where `answers` is an iterator yielding ``ConceptRow``s, where each concept row is effectively a mapping from variable names (not including the
`$` sigil) to their values in the row.
--

Java::
+
--
Follow the xref:{page-version}@manual::connecting/connection.adoc[connection guide]
to connect the `driver` to a TypeDB server.

[subs="macros, post_replacements, replacements"]
++++
Open a transaction to the selected database and use the
xref:{page-version}@drivers::java/api-reference.adoc#_Transaction_query__java_lang_String[transaction.query()]
method:
++++

[,java,indent=0]
----
try (TypeDBTransaction tx = driver.transaction(DB_NAME, Transaction.Type.READ)) {
    String query = """
      match
        $user1 has username $name1;
        $user2 has username $name2;
        friendship($user1, $user2);
        $name1 < $name2;
    """;
    ConceptRowsIterator answers = tx.query(query).resolve().asConceptRows();
}
----

Where `answers` is an iterator yielding ``ConceptRow``s, where each concept row is effectively a mapping from variable names (not including the
`$` sigil) to their values in the row.
--
====

== JSON (Concept documents)

A data pipeline ending with a `fetch` stage will produce JSON answers.


[tabs]
====
Studio::
+
--
Follow the xref:{page-version}@manual::studio.adoc#_connect_to_typedb[Studio manual]
to connect to TypeDB and select a project folder.
Then use the steps below:

. Use a drop-down list in the top toolbar to select a database.
. Select the desired transaction type.
. Open a new tab and insert or type in an insert stage, for example:
+
. Run the query by clicking the image:{page-version}@home::studio-icons/svg/studio_run.svg[width=24] btn:[Run Query] button.
. Commit the changes by clicking the image:{page-version}@home::studio-icons/svg/studio_check.svg[width=24] btn:[Commit query] button.

.Sample query
[,typeql]
----
match
  $user1 has username $name1;
  $user2 has username $name2;
  friendship($user1, $user2);
  $name1 < $name2;
fetch {
    "friend1": $name1,
    "friend2": $name2,
};
----

Each output is printed as a valid JSON object with the format specified by the fetch query.

.Sample output
[,typeql]
----
## Running>
match
    $user1 has username $name1;
    $user2 has username $name2;
    friendship ($user1, $user2);
    $name1 < $name2;
fetch {
    "friend1": $name1,
    "friend2": $name2,
};

## Result> Success.
{
    "friend1": "user1",
    "friend2": "user2"
}
{
    "friend1": "user1",
    "friend2": "user3"
}
## Completed
----

--

Console::
+
--
Open a transaction of the desired type (`read`, `write`, or `schema`):

[,bash]
----
> transaction sample_db read
sample_db::read>
----

Each output is printed as a valid JSON object with the format specified by the fetch query.

[,bash]
----
test::read> match
                $user1 has username $name1;
                $user2 has username $name2;
                friendship ($user1, $user2);
                $name1 < $name2;
            fetch {
                "friend1": $name1,
                "friend2": $name2,
            };
            
Finished validation and compilation...
Streaming documents...

{
    "friend1": "user1",
    "friend2": "user2"
}
{
    "friend1": "user1",
    "friend2": "user3"
}

Finished. Total answers: 2
----
--
====

[tabs]
====
Rust::
+
--
Follow the xref:{page-version}@manual::connecting/connection.adoc[connection guide]
to connect the `driver` to a TypeDB server.

[subs="macros, post_replacements, replacements"]
++++
Open a transaction to the selected database and use the
xref:{page-version}@drivers::rust/api-reference.adoc#_struct_Transaction_query__[transaction.query()]
method to send the query:
++++

[,rust,indent=0]
----
let transaction = driver.transaction(DB_NAME, TransactionType::Read).await.unwrap()?;
let query = "
  match
    $user1 has username $name1;
    $user2 has username $name2;
    friendship($user1, $user2);
    $name1 < $name2;
  fetch {
      "friend1": $name1,
      "friend2": $name2,
  };
";
let answers = transaction.query(query).await?;
----

Where `answers` is a `QueryAnswer` holding the stream of ``ConceptDocument``s.
Each `ConceptDocument` is equivalent to a JSON and can be serialized as such.
--

Python::
+
--
Follow the xref:{page-version}@manual::connecting/connection.adoc[connection guide]
to connect the `driver` to a TypeDB server.

[subs="macros, post_replacements, replacements"]
++++
Open a transaction to the selected database and use the
xref:{page-version}@drivers::python/api-reference.adoc#_Transaction_query[transaction.query()]
method to send the query:
++++

[,python,indent=0]
----
with driver.transaction(DB_NAME, TransactionType.READ) as tx:
    query = """
      match
        $user1 has username $name1;
        $user2 has username $name2;
        friendship($user1, $user2);
        $name1 < $name2;
      fetch {
          "friend1": $name1,
          "friend2": $name2,
      };
    """
    answers = tx.query(insert_query).resolve()
----

Where `answers` is an iterator yielding ``ConceptDocument``s.
Each `ConceptDocument` is equivalent to a JSON and can be serialized as such.
--

Java::
+
--
Follow the xref:{page-version}@manual::connecting/connection.adoc[connection guide]
to connect the `driver` to a TypeDB server.

[subs="macros, post_replacements, replacements"]
++++
Open a transaction to the selected database and use the
xref:{page-version}@drivers::java/api-reference.adoc#_Transaction_query__java_lang_String[transaction.query()]
method:
++++

[,java,indent=0]
----
try (TypeDBTransaction tx = driver.transaction(DB_NAME, Transaction.Type.READ)) {
    String query = """
      match
        $user1 has username $name1;
        $user2 has username $name2;
        friendship($user1, $user2);
        $name1 < $name2;
    """;
    ConceptDocumentsIterator answers = (ConceptRowIterator)tx.query(query).resolve().asConceptDocuments();
}
----

Where `answers` is an iterator yielding ``ConceptDocument``s.
Each `ConceptDocument` is equivalent to a JSON and can be serialized as such.
--
====

