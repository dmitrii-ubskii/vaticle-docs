= Reading data

This page explains how to read data from a TypeDB database.

// TODO: Should we mention schema?

== Understanding read pipelines

A read pipeline is a pipeline performing only read operations.
It can consist of one xref:{page-version}@typeql::pipelines/match.adoc[`match` stage] or different combinations of xref:{page-version}@typeql::pipelines/match.adoc[`match`], xref:{page-version}@typeql::pipelines/select.adoc[`select`], xref:{page-version}@typeql::pipelines/sort.adoc[`sort`], xref:{page-version}@typeql::pipelines/fetch.adoc[`fetch`], and other stages and operators.

Most of the read stages produce concept rows (the only exception is <<_fetch, fetch>>), which allows connecting them in an extensible pipeline.
These operations can be executed in any of the `schema`, `write`, or `read` xref:{page-version}@manual::queries/transactions.adoc[transactions].

Refer to the xref:{page-version}@typeql::pipelines/index.adoc[] page to explore all types of read pipelines and possible operations with them.

== Using match stages

[#_schema_note]
[NOTE]
====
The examples below can be combined with the following schema file.
A part of this file is defined in the respective xref:{page-version}@manual::schema/index.adoc[definition manuals].
Also, the data queried in these examples is inserted in the xref:{page-version}@manual::CRUD/inserting.adoc[insertion manual].

[[schema-include]]
.See the schema.tql
[%collapsible]
=====
.schema.tql
[,typeql]
----
include::{page-version}@home::example$tql/schema_small.tql[]
----
=====
====

You can query your data using TypeQL's xref:{page-version}@typeql::pipelines/match.adoc[`match` keyword] the same way you xref:{page-version}@manual::CRUD/inserting.adoc[insert] it.
As usual, multiple statements can be combined to declare multiple variables and establish connections between them.

[#_read_instance]
=== Read an instance

To read type instances (an xref:{page-version}@typeql::statements/entity.adoc[entity], a xref:{page-version}@typeql::statements/relation.adoc[relation], or an xref:{page-version}@typeql::statements/attribute.adoc[attribute]), use the xref:{page-version}@typeql::statements/isa.adoc[`isa` keyword]:

.Users reading example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user]
----

This simple query will return all the `user` s in the database.

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $u | iid 0x1e00030000000000000002 isa user
   --------
    $u | iid 0x1e00030000000000000003 isa user
   --------
    $u | iid 0x1e00030000000000000004 isa user
   --------
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

=== Read specific instances

Combining statements, it is possible to add more constraints to the `match`.
For example, the following query searches for all `user` s with a specific `username` using the xref:{page-version}@typeql::statements/has.adoc[`has` statement] (which can be interpreted as "the `user` with a specific `username` " as this attribute is a xref:{page-version}@typeql::annotations/key.adoc[key]):

[#_specific_users_example]
.Specific users reading example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-single-user]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

=== Read attributes and values

Attributes and their values can be read in a similar way.
By variablizing the attribute part of the <<_specific_users_example, previous example>>, it's easy to get all `user` s and their `username` s.
You can also use anonymous variables (`$_`) if they are not needed in the output:

[#_specific_users_example]
.Matching all users' usernames example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user-usernames-anonymous]
----

[NOTE]
====
While the same result for our schema could be achieved through:

.Matching all usernames example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-usernames]
----

the original query ensures that these `username` s are owned by other instances, not just exist in the database.
====

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $n | Alice isa username
   --------
    $n | Bob isa username
   --------
    $n | Charlie isa username
   --------
    $n | User isa username
   --------
----
====

While the attribute is variablized, it is also possible to put the same constraints from the <<_specific_users_example, specific user search example>> on it.
For instance, we can use the same attribute variable twice in two compatible statements:

.Specific users reading with variablized attribute example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-single-user-attribute-var]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $n | User isa username
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

To achieve the same result, we could also compare the attribute variable's value with the used constant:

.Specific users reading with variablized attribute and value comparison example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-single-user-attribute-var-compare]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $n | User isa username
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

Alternatively, we could declare a value variable using the xref:{page-version}@typeql::statements/let-eq.adoc[`let` statement], and integrate comparison into the owner instance declaration:

.Specific users reading using value variables example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-single-user-value-var]
----

[NOTE]
====
Here, `$n` will be a value variable, not an attribute variable, so it's cleaner to compare with it instead of binding from the previous examples.
Try comparing the outputs of this and the previous examples.
====

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $n | User
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

=== Read relations

Similarly to xref:{page-version}@manual::CRUD/inserting.adoc[insertion], matching relations based on their roleplayers supports multiple formats, suitable for different goals and approaches.

The most explicit way to bind a variable with a relation is:

.Matching relation linking two instances with specific roles example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-users-friendship]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $a | iid 0x1e00030000000000000002 isa user
    $b | iid 0x1e00030000000000000003 isa user
    $f | iid 0x1f00020000000000000000 isa friendship
   --------
----
====

If you are sure that these two `user` s can only play specific roles in a `friendship` or your intent is to query for any roles these `user`s play in a relation, the query can be simplified:

.Matching relation linking two instances of any roles example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-users-friendship]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $a | iid 0x1e00030000000000000002 isa user
    $b | iid 0x1e00030000000000000003 isa user
    $f | iid 0x1f00020000000000000000 isa friendship
   --------
----
====

TypeDB and TypeQL also support further simplification in case you are interested in only the `user` s, so the `friendship` between them is not needed in the output:

[#_matching_relation_linking_without_var_example]
.Matching relation linking two instances without a variable example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-users-friendship-users-only]
----

[NOTE]
====
It is an equivalent of the anonymous variable usage:

.Matching relation linking two instances with an anonymous variable example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-users-friendship-anonymous]
----
====

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $a | iid 0x1e00030000000000000002 isa user
    $b | iid 0x1e00030000000000000003 isa user
   --------
----
====

=== Negate, conjunct, and disjunct

All the examples you saw so far use only xref:{page-version}@typeql::patterns/conjunctions.adoc[conjunctions]: while writing multiple statements with semicolons between them and any additional syntax shown below, these conditions are combined to produce the result (there is a logical "AND" between them).

It is possible to `match` a broader range of results using xref:{page-version}@typeql::patterns/disjunctions.adoc[disjunctions] (logical "OR"):

.Matching with disjunction example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user-or-user]
----

[NOTE]
====
Note that multiple semicolons are required: one semicolon for each single statement and a final semicolon to finalize the disjunction.
====

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $u | iid 0x1e00030000000000000002 isa user
   --------
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

Similarly, xref:{page-version}@typeql::patterns/negations.adoc[negations] (logical "NOT") to reverse the declared constraint.
The following example returns all `user` s without `email` s:

.Matching with negation example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user-no-emails]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $u | iid 0x1e00030000000000000005 isa user
   --------
----
====

Combine negations, conjunctions, and disjunctions.
However, be aware that an inefficient query with lots of negations and disjunctions may take time to execute.
See xref:{page-version}@typeql::patterns/index.adoc[] for more details about patterns.

=== Read types

Types from database schemas are also available for `match` ing and retrieving.
To bind a variable to a type, use type-related statements and variablize the respective side.
The following example query retrieves the root types (types without supertypes) of the owners of attributes of type labelled `email`, using the xref:{page-version}@typeql::statements/isa.adoc[`isa` statement], the xref:{page-version}@typeql::statements/label.adoc[`label` statement], and the xref:{page-version}@typeql::statements/sub.adoc[`sub!` statement]:

.Matching types example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user-emails-supertypes]
----

.Example TypeDB Console output
[%collapsible]
====
----
   ---------------------
    $attribute-type | type email
    $owner-type     | type content
   ---------------------
----
====

The full list of statements, including the ones available for `match` ing, is available xref:{page-version}@typeql::statements/index.adoc[here].

Refer to the xref:{page-version}@typeql::pipelines/match.adoc[] page for a detailed explanation and additional examples.

== Operating on outputs

For now, we only covered single `match` stages.
However, it is possible to use the matched results in the following pipeline stages for further actions (e.g., in an xref:{page-version}@manual::CRUD/inserting.adoc[insert] or xref:{page-version}@manual::CRUD/deleting.adoc[delete] pipelines) or results modifications.

It is frequently useful to get only a specific set of variables instead of everything that is matched in the constraint declarations.
To select the necessary variables from the <<_matching_relation_linking_without_var_example, previous example>>, use the xref:{page-version}@typeql::pipelines/select.adoc[select operator]:

.Selecting variables example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-users-friendship-select]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $f | iid 0x1f00020000000000000000 isa friendship
   --------
----
====

To sort the outputs by chosen variables, use the xref:{page-version}@typeql::pipelines/sort.adoc[sort operator]:

.Sorting results in descending order example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-users-and-names-sorted]
----

.Example TypeDB Console output
[%collapsible]
====
----
   --------
    $n | User isa username
    $u | iid 0x1e00030000000000000005 isa user
   --------
    $n | Charlie isa username
    $u | iid 0x1e00030000000000000004 isa user
   --------
    $n | Bob isa username
    $u | iid 0x1e00030000000000000003 isa user
   --------
    $n | Alice isa username
    $u | iid 0x1e00030000000000000002 isa user
   --------
----
====

As the mentioned operators can reuse the variables from previous pipeline stages and produce their own results, it is a common approach to combine multiple stages in complex pipelines.
Continue exploring pipelines in the xref:{page-version}@manual::CRUD/pipelines.adoc[] manual.

Refer to xref:{page-version}@typeql::pipelines/index.adoc[] to explore all pipeline stages and operators.

[#_fetch]
== Converting output to JSON documents

Results of most of (and all read) pipeline stages in TypeDB can be converted into documents of the JSON format using `fetch`.
The main purpose of it is to present the data in a more readable format and export it for connecting with other applications.
However, this powerful tool not only allows you to flexibly structure your output based on variables, but also to perform subquerying operations, xref:{page-version}@manual::schema/functions.adoc[function] calls, reference instance's attributes, and much more.

[NOTE]
====
You can use `fetch` after any stage producing rows, even if you xref:{page-version}@manual::CRUD/inserting.adoc[insert] or xref:{page-version}@manual::CRUD/deleting.adoc[delete] data.
====

Fetch receives a number of input rows and converts each row into a document of the provided structure, adding more requested information based on the query.

For example, you can simply label all the matched results and address their attributes (if applicable):

.Creating a document of users example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user-usernames-fetch]
----

.Example TypeDB Console output
[%collapsible]
====
----
{
    "matched username": "Alice",
    "user email": "alice@typedb.com"
}
{
    "matched username": "Bob",
    "user email": "bob@typedb.com"
}
{
    "matched username": "Charlie",
    "user email": "charlie@typedb.com"
}
{
    "matched username": "User",
    "user email": null
}
----
====

[NOTE]
====
The example above shows the difference between matching using attributes and accessing attributes.
Notice that the output of the previous `fetch` query contains `null`: it happens because the first `match` stage returned all `user` s with `username` s, and `fetch` had to process every incoming row without changing the number of answers, even if the request cannot be satisfied.

However, the query execution would return an error if the `fetch` stage was completely unsatisfiable.
To achieve this, you can try accessing attributes of an attribute.
====

As you can see, every symbol after the `fetch` keyword declares the structure of the output documents.
This way, it's possible to specify any level of nesting required.
Similarly, you can achieve returning lists of attributes (it is even required if the cardinality of the ownership is not limited by 1).

The following is an example of documents nesting and lists usage.
We also produce an additional document containing every existing attribute of the instance using `.*`.

.Creating a document of users with nesting and lists example
[,typeql]
----
include::{page-version}@manual::example$tql/read_queries.tql[tags=match-user-fetch]
----

.Example TypeDB Console output
[%collapsible]
====
----
{
    "all user attributes": {
        "email": "alice@typedb.com",
        "username": "Alice"
    },
    "user information": {
        "emails": [ "alice@typedb.com" ],
        "username": "Alice"
    }
}
{
    "all user attributes": {
        "email": "bob@typedb.com",
        "username": "Bob"
    },
    "user information": {
        "emails": [ "bob@typedb.com" ],
        "username": "Bob"
    }
}
{
    "all user attributes": {
        "email": "charlie@typedb.com",
        "username": "Charlie"
    },
    "user information": {
        "emails": [ "charlie@typedb.com" ],
        "username": "Charlie"
    }
}
{
    "all user attributes": { "username": "User" },
    "user information": {
        "emails": [  ],
        "username": "User"
    }
}
----
====

[NOTE]
====
As you can see in this example, the missing `email` is represented differently.

Wrapping `null` s in lists produces empty lists `[ ]`, while the `.*` command matches only existing attributes, thus, does not mention `null` s.
====

Refer to xref:{page-version}@typeql::pipelines/fetch.adoc[] to explore all applications of `fetch`, its syntax, and more examples with subqueries, functions, and much more.

== Having troubles?

include::{page-version}@manual::page$CRUD/inserting.adoc[tag=having-troubles]
